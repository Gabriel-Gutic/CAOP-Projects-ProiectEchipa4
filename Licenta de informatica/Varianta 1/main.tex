\documentclass{beamer}
\mode<presentation>

\usetheme{Madrid}

\usepackage{lipsum}

\usepackage{bibentry}
\usepackage{listings}
\usepackage{caption}

\definecolor{darkgreen}{RGB}{0, 163, 43}

\lstset{
    language=Python,
    basicstyle=\small\ttfamily,
    commentstyle=\color{red}\itshape,
    stringstyle=\color{orange},
    numbers=left,
    numbersep=5pt,
    xleftmargin=20pt,
    frame=tb,
    framexleftmargin=20pt,
    keywordstyle=\color{blue}\bfseries,
    emph={Window, Table, Image, Point},
    emphstyle = \color{darkgreen}
}

\renewcommand*\thelstnumber{\arabic{lstnumber}:}

\DeclareCaptionFormat{mylst}{\hrule#1#2#3}
\captionsetup[lstlisting]{format=mylst,labelfont=bf,singlelinecheck=off,labelsep=space}


\usepackage{graphicx}
\usepackage{float}
\graphicspath{{Images}}


\title{Licen\c t\u a informatic\u a}
\subtitle{Problema Reginelor}
\author{
    A. Student Iacob Iustina
}
\institute[]{
    Facultatea de Matematic\u a \\
    Specializarea Matematic\u a - Informatic\u a
    \and
    Universitatea "Al. I. Cuza" Ia\c si\\
    Facultatea de Matematic\u a
}
\date{Iulie 2022}
\titlegraphic{
    \includegraphics[width=1cm]{sigla.jpg} \hfill
    \includegraphics[width=1cm]{sigla.png}
}


\begin{document}
    
\frame{\titlepage}

\begin{frame}{Cuprins}
    \tableofcontents[currentsection]
\end{frame}

\section{Enun\c t}

\begin{frame}{Problema reginelor}
    \begin{block}{Enun\c t}
        Dându-se o tablă de 
        şah de dimensiune nxn (\(n > 1\)) să se aranjeze 
        pe ea n regine fără ca ele să se atace. 
        Reamintim că o regină atacă linia, coloana 
        şi cele 2 diagonale pe care se află. În 
        figura de mai jos celulele colorate mai 
        închis sunt atacate de regina poziţionată \^ in caseta (0, 0).
    \end{block}
    \begin{figure}
        \includegraphics[width=0.3\textwidth]{1.png}
    \end{figure}
\end{frame}

\section{Crearea ferestrei \c si a tabelului}

\begin{frame}[fragile]{Crearea ferestrei \c si a tabelului}
    \begin{block}{Descriere}
        \lipsum[1][1-3]
    \end{block}

    \begin{lstlisting}[caption={Slider creation}]
window = Window("Queen", 800, 600)

table = Table(window, 5, center=Point(400, 300))
    \end{lstlisting}
\end{frame}

\section{Punctul de pornire al algoritmului}

\begin{frame}[fragile]{Punctul de pornire al algoritmului}

\begin{lstlisting}[caption={Start Function}]
def start():
    slider_rows.set_visible(False)
    start_button.set_visible(False)
    w = table.squares[0][0].width
    for i in range(table.rows):
        queens.append({
        'col': None,
        'image': Image(window, width=w, height=w, 
                        path="../images/queen.png"),
        })
        queens[i]['image'].set_visible(False)

    backtracking_thread = threading.Thread(
        target=backtracking_init)
    backtracking_thread.start()
\end{lstlisting}
    
\end{frame}

\section{Algoritmul}
\subsection{Explica\c tii}

\begin{frame}{Algoritmul}
    \begin{block}{Explica\c tie 1}
        \lipsum[1][1]
    \end{block}

    \begin{block}{Explica\c tie 2}
        \lipsum[1][1-2]
    \end{block}

    \begin{block}{Explica\c tie 3}
        \lipsum[2][1-3]
    \end{block}
\end{frame}

\begin{frame}[fragile]{Algoritmul}
    \begin{block}{Explica\c tie}
        \lipsum[1][1-2]
    \end{block}

    \subsection{Prezentare}

    \begin{lstlisting}{Code}
def back(k):
    for i in range(table.rows):
        global is_running
        if not is_running:
            return False
        queens[k]['col'] = i
        queens[k]['image'].center = 
                table.squares[k][i].center
        queens[k]['image'].set_visible(True)

    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Algoritmul}
    \begin{lstlisting}
        pause()
        if valid(k):
            if solution(k):
                show_solution()
            else:
                back(k + 1)
    queens[k]['image'].set_visible(False)
    pause()
    \end{lstlisting}

    \subsection{Precizare}
    \begin{block}{Precizare}
        \lipsum[1][3-5]
    \end{block}
\end{frame}

\section{Despre algoritm}
\begin{frame}{Despre algoritm}
    \begin{exampleblock} {\^Intrebare}
        Ce metod\u a utilizeaz\u a acest algoritm?
    \end{exampleblock}
    \begin{block} {R\u aspuns}
        Metoda utilizat\u a este cea de backtracking, \^intruc\^at ...
        \lipsum[1][1-6]
    \end{block}
\end{frame}

\begin{frame}{Despre algoritm}
    \begin{block}{Cazul \(n \leq 3 \)}
        \^ In aceast\u a situa\c tie programul nu va
        afi\c sa nici o variant\u a corect\u a, deoarece e imposibil
        s\u a plas\u am, de exemplu, 3 regine pe o tabl\u a de dimensiune 3x3 f\u ar\u a 
        s\u a se atace reciproc.
    \end{block}
    \begin{block}{Cazul \(n>3\)}
        \^In aceast\u a situa\c tie, programul va afi\c sa mereu o
        variant\u a corect\u a.        
    \end{block}
\end{frame}

\section{\^ Intreb\u ari}
\begin{frame}{\^ Intreb\u ari}
    \begin{exampleblock} {\^Intrebarea 1}
        Ce complexitate are algoritmul?
    \end{exampleblock}
    \begin{exampleblock} {\^Intrebarea 2}
        Este cea mai eficient\u a variant\u a?
    \end{exampleblock}
    \begin{exampleblock} {\^Intrebarea 3}
        Care sunt avantajele utiliz\u arii acestui algoritm 
        realizat prin metoda backtracking?
    \end{exampleblock}
\end{frame}

\section{Bibliografie}
\begin{frame}[allowframebreaks]{Bibliografie}
~\cite{javaTpoint}
~\cite{alghdesign}
~\cite{nqueensartcl}

    \bibliographystyle{amsalpha}
    \bibliography{biblio.bib}
\end{frame}
\end{document}